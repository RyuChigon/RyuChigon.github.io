{"pageProps":{"frontMatter":{"title":"백준 11779 파이썬","date":"2022-7-20","description":"백준 11779 파이썬 풀이","tags":["dijkstra's","algorithm"]},"slug":"bj11779","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"문제 링크\"\n    }), \"\\n\", _jsx(\"a\", {\n      href: \"https://www.acmicpc.net/problem/11779\",\n      target: \"_blank\",\n      children: \"https://www.acmicpc.net/problem/11779\"\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.h2, {\n      children: \"풀이 방식\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Dijkstra를 이용하여 최소 비용을 계산한다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"경로 또한 구하기 위해 최소 비용을 업데이트 할 때 마다 path를 갱신해준다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"코드\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" sys, heapq\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"input\"\n        }), \" = sys.stdin.readline\\r\\nn = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"int\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"input\"\n        }), \"())\\r\\nm = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"int\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"input\"\n        }), \"())\\r\\ngraph = [[] \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" _ \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"range\"\n        }), \"(n + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" _ \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"range\"\n        }), \"(m):\\r\\n    _s, _e, cost = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"map\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"int\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"input\"\n        }), \"().split())\\r\\n    graph[_s].append((_e, cost))\\r\\nstart, end = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"map\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"int\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"input\"\n        }), \"().split())\\r\\n\\r\\ndistance = [\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"float\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'inf'\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" _ \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"range\"\n        }), \"(n + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\npath = [[] \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" _ \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"range\"\n        }), \"(n + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\npath[start].append(start)\\r\\nheap = [(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", start)]\\r\\nheapq.heapify(heap)\\r\\n\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" heap:\\r\\n    cost, node = heapq.heappop(heap)\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" cost > distance[node]:\\r\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \"\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" node == start:\\r\\n        distance[node] = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" next_node, next_cost \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" graph[node]:\\r\\n        next_cost += cost\\r\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" next_cost < distance[next_node]:\\r\\n            distance[next_node] = next_cost\\r\\n            heapq.heappush(heap, (next_cost, next_node))\\r\\n            path[next_node] = path[node] + [next_node]\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(distance[end])\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"len\"\n        }), \"(path[end]))\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"' '\"\n        }), \".join(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"map\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"str\"\n        }), \", path[end])))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"후기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Dijkstra 알고리즘은 최단 거리, 최소 비용을 구할 때 유용하게 사용된다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}