{"pageProps":{"frontMatter":{"title":"Shader","date":"2023-2-22","description":"Basic of shader","tags":["shader"]},"slug":"shader","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h3: \"h3\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"br\", {}), \"\\n\", _jsx(_components.h1, {\n      children: \"용어\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Rendering\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"2D 또는 3D Mesh, 광원의 위치, 게임 카메라의 앵글 같은 씬 정보로부터 이미지를 만드는 과정\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Mesh\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컴퓨터가 이해할 수 있는 형식으로 대상의 형태를 정의하는 방법 중 하나\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Vertex 위치 정보의 집합으로 형태를 정의\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Vertices: 점\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Edges: Vertices 연결한 선\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Faces: 세 개 또는 그 이상의 Edges로 구성된 2D형태. Edges로 둘러 쌓인 공간. 처리 속도와 간결함을 위해 삼각형 형태를 주로 사용\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드에서 매우 쉽게 정의할 수 있어 컴퓨터 그래픽에서 널리 사용된다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"메쉬는 오직 Vertices만을 메모리에 저장한다. Edges와 Faces는 Vertex ordering을 간접적으로 정의한다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"메쉬 데이터에 \", _jsx(_components.code, {\n        children: \"Vertex가 저장되는 순서\"\n      }), \"에 따라 단순히 버텍스 순서를 결정하는 경우가 있다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"반면 \", _jsx(_components.code, {\n        children: \"Index buffer\"\n      }), \"라는 데이터 구조를 통해 버텍스 순서를 정의하는 경우도 있다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Vertex order는 2D 형태인 페이스의 앞면을 결정한다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"winding order\"\n      }), \": Vertex 순서가 정해지는 방향\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"backface culling\"\n      }), \": Face의 뒷면을 렌더링하지 않는 최적화 기술\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Rendering Pipeline\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"메쉬를 화면의 이미지로 만들기 위해 GPU가 처리하는 과정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단한 과정\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"메쉬 버텍스 데이터\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"버텍스 셰이더\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"현재 처리하는 메쉬의 Vertex를 화면 어디에 그려야 하는지 정의\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"형태 조립\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"버텍스를 선으로 연결하여 Edge를 배치\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"래스터화\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"GPU가 앞서 처리한 메쉬가 화면에서 차지할 가능성이 있는 픽셀을 계산.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"픽셀 후보에 대해 프래그먼트 생성\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"프래그먼트: 화면에 픽셀을 그리기 위해 필요한 모든 정보를 담은 데이터 구조 (잠재적인 픽셀)\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"아직 메쉬의 표면이 어떤 모습인지 확인할 수 없음\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"프래그먼트 셰이더\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"프래그먼트의 색상 정보를 배치\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"프래그먼트 처리\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"프래그먼트 테스팅\", \"\\n\", _jsxs(_components.ul, {\n              children: [\"\\n\", _jsx(_components.li, {\n                children: \"어떤 프래그먼트를 화면에 그리고, 버릴 것인지 판단하는 과정\"\n              }), \"\\n\", _jsx(_components.li, {\n                children: \"메쉬의 프래그먼트를 생성할 때 전체 씬에 대한 정보는 고려하지 않기 때문에 GPU는 화면에 실제로 그릴 픽셀보다 더 많은 프래그먼트를 생성한다.\"\n              }), \"\\n\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"브랜딩 연산\", \"\\n\", _jsxs(_components.ul, {\n              children: [\"\\n\", _jsx(_components.li, {\n                children: \"반투명한 물체 처리\"\n              }), \"\\n\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파이프라인은 전적으로 GPU에서 처리된다. -> 게임에서 GPU가 중요한 이유\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Shader: 렌더링 파이프라인의 일부 단계에서 실행되면서 그 단계들을 제어하는 프로그램\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}